* Removing Scroll, Tool and Menu bars

It's very easy to set those things. We only need three elisp lines of code on custom-set-variables:


#+BEGIN_SRC emacs-lisp

(custom-set-variables
 '(menu-bar-mode nil)
 '(scroll-bar-mode nil)
 '(tool-bar-mode nil))

#+END_SRC

* Removing Welcoming Screen

#+BEGIN_SRC emacs-lisp

(setq inhibit-startup-screen t)

#+END_SRC

* Opening Always on Fullscreen Mode

There is also a simple command for that. What we are doing is simply adding the specification for the window size to the variable 'default-frame-alist.

#+BEGIN_SRC emacs-lisp

(add-to-list 'default-frame-alist '(fullscreen . maximized))

#+END_SRC

* Starting Server (Daemon Mode)

The emacs Daemon Mode is very useful beacuse you can open files from the terminal that won't open a new instance of emacs. Instead, the file will be shown in your current session of Daemon Emacs.
To open a file from terminal into your daemon emacs session, simply use the command 'emacsclient -n <filename>'. Some users like to make an alias for that command, which is pretty reasonable.

By using the following command on your init file, you get the daemon server started.

#+BEGIN_SRC emacs-lisp

(server-start)

#+END_SRC

* Indentation Configs

  To configure the indentation to use tabs of size 4 instead of spaces, we can setup a hook function that will be called when the language 
mode initiates. My config does that for c/cpp mode. One of the most important things for me is the /c-set-offset/ line, which sets the 
/substatement-open/ to 0. What it does is simply change the (for me) annoying indentation default

#+BEGIN_SRC C

//From this:
if(x)
  {
     //code;
  }

//To this:
if(x)
{
   //code;
}

#+END_SRC

  The other configs are quite self-explanatory. Maybe except the /tab-stop-list/. This is the list of spaces your TAB will stop. You can see
clearly that every item on the list corresponds to the previous + 4, which is reasonable.
  
#+BEGIN_SRC emacs-lisp

(defun my-c-mode-common-hook ()
 (c-set-offset 'substatement-open 0)

 (setq c++-tab-always-indent t)
 (setq c-basic-offset 4)                  
 (setq c-indent-level 4)                  

 (setq tab-stop-list '(4 8 12 16 20 24 28 32 36 40 44 48 52 56 60))
 (setq tab-width 4)
 (setq indent-tabs-mode t)  ; use spaces only if nil
 )

(add-hook 'c-mode-common-hook 'my-c-mode-common-hook)

#+END_SRC
  
* Package Archives

The first thing to do is to require the emacs package manager and to add org and MELPA package archives:

#+BEGIN_SRC emacs-lisp

(require 'package)

(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))

#+END_SRC

To enable all packages we want, we need to initialize packages and to set the initialization to nil for us to choose which packages we want to be loaded.

#+BEGIN_SRC emacs-lisp

(setq package-enable-at-startup nil)
(package-initialize)

#+END_SRC
* Packages
** let-alist (for older versions)

   Some versions of emacs don't come with /let-alist/ by default. It turns out that some packages depend on it, so I'll install it here.

#+BEGIN_SRC emacs-lisp

(unless (package-installed-p 'let-alist)
  (package-refresh-contents)
  (package-install 'let-alist))

#+END_SRC

** use-package

I decided to use /use-package/ because it is easy to migrate between machines and it is surely easy to install packages and load them.
To install it, we need a simple elisp code:

#+BEGIN_SRC emacs-lisp

(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

#+END_SRC

After that, we should require the package and evaluate it:

#+BEGIN_SRC emacs-lisp
(eval-when-compile
  (require 'use-package))
(setq use-package-always-ensure t)

#+END_SRC

** flycheck

   I'm still having problems with /use-package/ and /flycheck/. This implementation *does not* work for me yet. But I'll leave it here.

#+BEGIN_SRC emacs-lisp

(use-package flycheck
  :ensure t)

(use-package flycheck-irony
  :ensure t)

#+END_SRC emacs-lisp

** evil-mode

After installing use-package, we only need to specify the packages we need in a simple way.
We can use the ":ensure" to make sure that the package is going to be installed if it is not available.
I am also using ":init" have evil-mode always active when I open emacs.

#+BEGIN_SRC emacs-lisp

(use-package evil
  :init
  (evil-mode t)
  :ensure t)

(use-package evil-leader
  :ensure t)

#+END_SRC

** powerline

Installing powerline (and poweline-evil) and also configuring it to my selected theme.

#+BEGIN_SRC emacs-lisp

(use-package powerline
  :ensure t)

(use-package powerline-evil
  :ensure t
  :config (powerline-evil-vim-color-theme))

#+END_SRC

** org
   
Installing org is just as simple.

#+BEGIN_SRC emacs-lisp

(use-package org
  :ensure t)

(use-package evil-org
  :ensure t)

#+END_SRC

After that, I want to make some configurations to org. The thing I want is that my agenda commands get all of my TODOS from all org files.

#+BEGIN_SRC emacs-lisp

(defun org-agenda-timeline-all (&optional arg)
  (interactive "P")
  (with-temp-buffer
    (dolist (org-agenda-file org-agenda-files)
      (insert-file-contents org-agenda-file nil)
      (end-of-buffer)
      (newline))
    (write-file "/tmp/timeline.org")
    (org-agenda arg "L")))

(define-key org-mode-map (kbd "C-c t") 'org-agenda-timeline-all)

#+END_SRC

What I am doing is simply iterating through the variable org-agenda-files, which has a list of all org files to consider and, after that, making my timeline with all TODO's.
To insert an org file into the list (variable), you can use the command org-agenda-file-to-front ( or C-c [ ). This command will insert the file in your current buffer into the list of org agenda files.
To remove the file, simply use the command org-remove-file ( or C-c ] ).

After my function is made, I assigned it to the shortcut C-c t.

** magit

#+BEGIN_SRC emacs-lisp

(use-package magit
  :ensure t)

#+END_SRC
   
** projectile

#+BEGIN_SRC emacs-lisp

(use-package projectile
  :ensure t)

#+END_SRC
  
** helm
   
   Helm implements some fuzzy-search mechanisms that are really usefula for almost every search. It is important to note that it does a lot
more than that, but this is my primary reason for using it.

#+BEGIN_SRC emacs-lisp

(use-package helm
  :ensure t)

#+END_SRC

  Here I'll change some default keys and set them to the helm equivalents and enable /helm-mode/. /Helm-mode/ brings another fuzzy-search
funcionalities for other sets of commands.

#+BEGIN_SRC emacs-lisp

(global-set-key (kbd "M-x") #'helm-M-x)
(global-set-key (kbd "C-x r b") #'helm-filtered-bookmarks)
(global-set-key (kbd "C-x C-f") #'helm-find-files)

(helm-mode 1)

#+END_SRC

** dracula-theme

   /Dracula-theme/ is my favorite theme until now. Chances are that I'll change it later, but you can use this as a template for any other
theme that you like.

#+BEGIN_SRC emacs-lisp

(use-package dracula-theme
  :init (load-theme 'dracula t)
  :ensure t)

#+END_SRC

** relative-line-numbers

   /Relative-line-numbers/ is a good thing for /evil-mode/ because it shows the line numbers relative to the line you are on. For a more
clear visualization, search for images on the web. The fact is that on /vim/ it is very useful to know the number of line jumps to the
line you're interested in.

#+BEGIN_SRC emacs-lisp

(use-package relative-line-numbers
  :config (global-relative-line-numbers-mode)
  :ensure t)

#+END_SRC
